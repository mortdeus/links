package link

import (
	"fmt"
	"reflect"
)

// LinkedObject should be embedded
type LinkedObject struct {
	provider *Provider

	// reference to the websocket
	connID uint64

	// id for the linked object, generated by client
	id uint64

	parent, child Linker

	container Linker
}
type Provider int

func (l *LinkedObject) Link(i interface{}) error {
	if _, ok := i.(Linker); !ok {
		return new(NotLinkerErr)
	}
	switch lo := i.(type) {
	case LinkedObject:
		lo.parent, l.child = l, &lo
		return nil
	/*
		And check whatever other linker types you know about
		linkfoo:
		linkbar:
		etc
	*/
	default:
		linkval := reflect.ValueOf(i)
		fval := linkval.FieldByNameFunc(func(s string) bool {
			switch s {
			case "LinkedObject", "*LinkedObject":
				if f, ok := linkval.Type().FieldByName(s); ok && f.Anonymous {
					return true
				}
			}
			return false
		})

		if fval.IsValid() {
			if fval.Kind() != reflect.Ptr && fval.CanAddr() {
				l.child = fval.Addr().Interface().(Linker)
			} else {
				l.child = fval.Interface().(Linker)
			}
			l.child.(*LinkedObject).parent = l
			return nil
		}
		l.child = &LinkedObject{parent: l, container: i.(Linker)}
		return nil
	}
}
func (l *LinkedObject) Parent() interface{} {
	return l.parent
}
func (l *LinkedObject) Child() interface{} {
	return l.child
}
func (l *LinkedObject) String() string {
	return fmt.Sprint(reflect.TypeOf(l).String())
}

// makes any type embedding LinkedObject implement this interface
type Linker interface {
	Link(interface{}) error
	Parent() interface{}
	Child() interface{}
}

type NotLinkerErr int

func (err NotLinkerErr) String() string {
	return "This type is not a valid linker"
}
func (err NotLinkerErr) Error() string {
	return err.String()
}

func LinkerInfo(l Linker) {
	fmt.Println(l, "\n")
}
